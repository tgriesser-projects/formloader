<?php

namespace Formloader;

/**
 * API for reading/writing to the FS for Formloader FS
 * 
 * @package   Formloader
 * @version   1.0
 * @author    Tim Griesser
 * @license   MIT License
 * @copyright 2012 Tim Griesser
 * @link      http://formloader.tgriesser.com
 */
class Formloader_Fs
{
	/**
	 * Headers for the output
	 * @var array
	 */
	protected static $headers = array();

	/**
	 * Directories for saving/reading form info
	 * @var array
	 */
	protected static $dirs = array();

	/**
	 * When we query a directory, we cache it here
	 * @var array
	 */
	protected static $fs_cache = array();
	
	/**
	 * Called by fuelPHP when the class is first initialized
	 * ...almost like a static constructor
	 */
	public static function _init()
	{
		self::$dirs = array(
			'output' => \Config::get('formloader.output_path').'/output',
			'forms'  => \Config::get('formloader.output_path').'/forms'
		);
		self::$headers['attributes'] = <<<HEAD
<?php
/**
 * Formloader: Auto Generated Form Configuration
 * --- Please do not edit this file directly... your changes will be overridden! ---
 */
HEAD;
		$date = date('Y/m/d H:i:s');
		self::$headers['items'] = <<<HEAD
<?php
/**
 * Formloader: Updated by Formloader Module - $date
 * --- You may edit the below, changes will not be lost, just appended---
 */
HEAD;
	}

	/**
	 * Grab an individual item based on the object's Id
	 * @param id
	 * @param type {form|fieldset|field|action}
	 */
	public static function fetch_item($id, $type)
	{
		$item = array();
		
		if (substr($id, 0, 2) === 'fs')
		{
			list($id, $group, $name) = explode('-', $id);

			if ( ! isset(self::$fs_cache[$group]))
			{
				self::fetch_group($group, false);
			}
			
			$item = \Arr::get(self::$fs_cache[$group], $type.'.'.$name, array());
			$item['name'] = $name;
			$item['group'] = $group;
		}
		else
		{
			# Database access can be added here
		}
		
		return $item;
	}

	/**
	 * Fetches a group
	 * @param  string {group name}
	 * @return Array
	 */
	public static function fetch_group($group)
	{
		if ( ! isset(static::$fs_cache[$group]))
		{
			foreach (array('actions', 'fields', 'fieldsets', 'forms', 'validations') as $item)
			{
				$path  = self::$dirs['forms'].DS.$group.DS.$item.'.php';
				self::$fs_cache[$group][$item] = Formloader::load_array($path);
			}
		}		
		return \Arr::get(static::$fs_cache, $group, array());
	}

	/**
	 * Grab a specific item from the group, i.e. the forms from the Formloader group
	 * @param  String  Group Name
	 * @param  String  Item Type
	 * @return Array
	 */
	public static function fetch_group_type($group, $type)
	{
		$group = Formloader_Fs::fetch_group($group);
		return $group[$type];
	}

	/**
	 * Save a type of group...
	 * @param String  Group Name
	 * @param String  Group Type
	 * @param Array   
	 */
	public static function save_group_type($group, $type, array $item)
	{
		$create = ! isset(self::$fs_cache[$group][$type]) ? : false;
		self::$fs_cache[$group][$type] = $item;
		ksort($item);
		self::save_item('forms', $group, "$type.php", self::prep_array_output('items', $group, $item));
		return $create;
	}

	/**
	 * Saves the attributes or output to the filesystem
	 * @param String  {forms|output}
	 * @param String  Group Name
	 * @param String  Filename
	 * @param String  Output to Save
	 */
	public static function save_item($type, $group, $filename, $code)
	{
		$output_dir = self::$dirs[$type].DS.$group;

		try
		{
			if ( ! is_dir(self::$dirs[$type]))
			{
				throw new FormloaderException("The output form directory $type does not exist!");
			}
			if ( ! is_dir($output_dir))
			{
				\File::create_dir(self::$dirs[$type], $group, 0755);
			}

			$action = ! file_exists($output_dir.DS.$filename) ? 'create' : 'update';

			\File::$action(
				$output_dir,
				$filename,
				$code
			);
		}
		catch (\InvalidPathException $e)
		{
			throw new FormloaderException("Invalid path, cannot update at... $output_dir");
		}
		catch (\FileAccessException $e)
		{
			throw new FormloaderException("Error saving the form, the directory could not be written");
		}
		
		return $action;
	}
		
	/**
	 * Cleans up the spacing on the generated array
	 * @param  String  Header Type
	 * @param  String  Name of the group we're in... so the notation is nicer (and relative)
	 * @param  String  Raw array we're saving...
	 * @return String  Cleaned up content
	 */
	public static function prep_array_output($header, $group, array $item)
	{
		$content = self::$headers[$header];
		$content .= "\n" . 'return '.str_replace(array('  ', "array ("), array("\t\t", 'array('), var_export($item, true)).";\n";

		// This could probably be cleaned up, but it works
		$preg_items = array(
			"#\d+ => #"        => '',                # takes out any keys that are int's to make the output readable
			'#=> \n#'          => '=> ',             # removes unnecessary newlines after the =>
			'#=>\s+array#'     => '=> array',        # brings array( to the same line when it is the value
			'#fs-(.*?)-(.*?)#' => '$1.$2',           # replaces the _id format to the dot format for the items
			"#$group\.(.*?)#"  => '$2',              # if it matches the group's name, we don't need this to be dot-separated...
			"#array\(\n\t+\n(\t+)#" => "array(\n$1", # more straightening up of the array(
			"#\n\t+\n(\t+)#"        => "\n$1",       # whitespace cleanup
			"#array\(\s+\),#"       => "array(),",   # empty arrays open/close on the same line
		);
		
		$content = preg_replace(array_keys($preg_items), array_values($preg_items), $content);
		$content = preg_replace_callback("#array\((\s+'(\S+)',\n)+\s+\),#", function($preg)
		{
			return str_replace(',),', '),', preg_replace("#\s+#", '', $preg[0]));
		}, $content);

		return $content;
	}

	/**
	 * Gets a certain type of a Formloader item, across all groups
	 * @param  String  Type {form, fieldset, field, action}
	 * @param  Bool    Whether we're fetching from the filesystem... 
	 * @return Array   Located items
	 */
	public static function fetch_type($type)
	{
		$results = array();
		$dir = \File::read_dir(self::$dirs['forms']);

		foreach ($dir as $group => $list)
		{
			if (is_array($list))
			{
				$group = rtrim($group, '/');
				$items = self::fetch_group($group);
				if (is_array($items[$type]))
				{
					$results[$group] = $items[$type];
				}
			}
		}
		return $results;			
	}

}